1. I create three file pointers, f1, f2, and result. I open matrix1.bin and matrix2.bin in read binary, I open result.bin in write binary. I then read the first line in the 2 matrix files to find the dimensions of the array and store it in dim1 and dim2. I check to see if they're the same numbers or not and print a message saying they arent the same size or that they are greater than 100 and return -1. I then create 3 triple pointers to a mat1, mat2 and resmat. Resmat is long long to accomodate larger sized multidimensional arrays. I then create 3 for loops where I malloc space in all my arrays in case the arrays in the passed files have a lot of numbers. In the last for loop, I fread from the bin files and store them in mat1[i][j][k] and mat2[i][j][k]. I close the files f1 and f2 because I no longer need them. I then create another 3 nested for loops where I multiply the elements in mat1 and mat2 then store them in resmat. I cast mat1 and mat2 to long long so that the result from multiplying is the same data type as resmat. I write the results to result.bin then free the 3 arrays I made and close the result file. I just now noticed that I could have just combined the 2 nested for loops I made.
2. I create a function called countLines where I pass in a const char* pathname which is the directory I ask for in main. I check if the passed directory exists and if it doesn't then I return -1 which I check in main to see if I can find it. I create a struct dirent entity and create a while loop that continues to run while there exists a directory. In my if statement, I check the type of the entity and if it's a directory, which I check with DT_DIR. If it is, I concatenate the pathname with the directory name. I set my count variable to count + countLines because my countLines will return the number of lines in a directory for the file. If the entity is not a directory and it's a file, DT_REG, then I do the same concatenation as before and create a file pointer. I open the file in read mode and create a for loop to read each character in the file. If the character is a \n then I add 1 to the current value of count. Once I'm done traversing the directory and exit the while loop, I close the directory and return the count, which is the number of lines across all directories. 
