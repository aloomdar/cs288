1. I have a #define max 100 line because the array should not hold more than 100 elements. I created a void radix function where I take in the unsigned int array and an int n size of the array. I create an unsigned bucket0, bucket1, mask, count0 and count1. I create a for loop that loops 32 times, for each binary bit. I create a mask 1<<d and set count1 and count0 to 0. I then create a for loop that loops through the passed n in the function and use bitwise & to compare the bits in A[i] and mask. If it's 0, I add A[i] to bucket0[count0] and increment count0. If the bitwise & isn't 0, then I do the same thing for bucket1 that I did for bucket0. Then I create a for loop to add the contents of bucket0 to the array A. Once that's done I do the same thing for bucket1 but I start adding in to array A at index count0+i because if I don't, then it will overwrite the existing information in those indices. In my main, I ask how many integers the user would like to enter and store it in var size. I create a while loop to enter integers and store it in var num and set A[i] to num then increment i until it reaches size. Then I call radix with array A and size then print the sorted array.
2. I use the same radix function in problem 1 but make a new radixSigned function. In radix signed I have parameters int A for array and unsigned int n for size of array. I create 2 unsigned int arrays for positive numbers and negative numbers. I create a for loop where I check if the passed arr A[i] is greater than or equal to 0 and if it is, then I put it in the array positive otherwise it goes to array negative where I negate it to get the positive value. Once that's done, I call the radix function on the negative and positive numbers array. Then I create 2 for loops where the first one takes all the numbers in the negative array and store it in A[i]. I negate whatever I am storing in the array A because I negated it previously which gave me the positive number version so now I negate it to get the negative version. The second for loop stores all the positive numbers in array positive at A[negCount + i] to avoid overwriting the data. In main I basically have the same thing I did in number 1, I just ask for real numbers instead of integers and store it in array A which is a float. I created an unsigned int pointer and set it equal to array A but cast it to unsigned int * so it would work properly. I don't FULLY understand why it works I just know it does. 
